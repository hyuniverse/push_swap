/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   push_swap.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: sehyupar <sehyupar@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/02/22 14:36:11 by sehyupar          #+#    #+#             */
/*   Updated: 2024/02/28 19:04:25 by sehyupar         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "push_swap.h"

int	find_a_index(t_stack *a, int b)
{
	int		cnt;
	t_node	*p;

	cnt = 0;
	p = a->top;
	while (cnt < a->size && p->data < b)
	{
		p = p->next;
		cnt++;
	}
	p = a->bottom;
	if (cnt == 0)
	{
		while (p && (cnt > (-1) * (a->size)) && p->data > b)
		{
			p = p->prev;
			cnt--;
			if (p && p->prev && p->data > p->next->data)
				break ;
		}
	}
	if (cnt < 0)
		cnt += (a->size); //(a->size - 1 인지 아닌지 판단해보기)
	return (cnt);
}

t_rotation	get_min_rotation(t_stack *a, t_stack *b, int pivot)
{
	t_rotation	res;
	t_rotation	tmp;
	t_node		*ptr;

	tmp.b = -1;
	res.b = b->size;
	if (a->size > b->size)
		res.total = a->size;
	else
		res.total = b->size;
	res.a = res.total;
	ptr = b->top;
	while (++tmp.b < pivot) //여기가 좀...
	{
		tmp.a = find_a_index(a, ptr->data);
		printf("%d-> a: %d\n", ptr->data, tmp.a);
		if (tmp.b > tmp.a)
			tmp.total = tmp.b;
		else
			tmp.total = tmp.a;
		if (tmp.total < res.total)
		{
			res.a = tmp.a;
			res.b = tmp.b;
			res.total = tmp.total;
		}
		ptr = ptr->next; 
	}
	if (res.a > a->size / 2) // b는 피벗 기준이라 해당안될 듯. 
		res.a -= a->size; 
	return (res);
}
/*
t_rotation	get_min_rotation(t_stack *a, t_stack *b, int pivot)
{
	t_rotation	res;

	return (res);
}
*/

void	sort_b(t_stack *a, t_stack *b, int pivot)
{
	t_rotation	rot;

	while (b->size > pivot)
	{
		//print_status(a, b);
		if (a->size != 0 && b->top->data != a->top->data - 1)
		{
			printf("!\n");
			if (pivot) 
				rot = get_min_rotation(a, b, pivot);
			else
				rot = get_min_rotation(a, b, b->size);
			printf("%d %d\n", rot.a, rot.b);
			rotate_stacks(a, b, &rot);
		}
		p(b, a);
		if (a->size > 1 && a->top->data > a->top->next->data)
			s(a, 1);
		print_status(a, b);
		//print_status(a, b);
	}
}

void	sort_a(t_stack *a)
{
	t_node	*ptr;
	int		cnt;

	ptr = a->top;
	cnt = 0;
	while (ptr)
	{
		if (ptr->data == 0)
			break ;
		ptr = ptr->next;
		cnt++;
	}
	if (cnt > a->size / 2)
	{
		cnt = a->size - cnt;
		while (cnt--)
			rr(a, 1);
	}
	else
	{
		while (cnt--)
			r(a, 1);
	}
}

int	push_swap(t_stack *a, t_stack *b)
{
	int	n;
	int	pivot;

	n = a->size;
	pivot = (int)(n / 2);
	while (n > 0) //전체 다 b로 넘기기
	{
		p(a, b);
		if (b->top->data < pivot)
			r(b, 1);
		n--;
	}
	sort_b(a, b, pivot);
	sort_b(a, b, 0);
	sort_a(a);
	print_status(a, b);
	return (0);
}

/*
int	push_swap(t_stack *a, t_stack *b)
{
	int	n;
	int	pivot1;
	int	pivot2;
	int	i;

	n = a->size;
	pivot1 = (int)((n - 3) / 2);
	pivot2 = (int)(n - 3);
	i = 0;
	print_status(a, b);
	while (i < n)
	{
		if (a->top->data < pivot2)
		{
			p(a, b);
			if (b->top->data < pivot1 && b->size > 1)
				r(b, 1);
		}
		else if (a->size > 1)
			r(a, 1);
		print_status(a, b);
		i++;
	}
	// a 정렬

	sort_b(a, b, pivot1);
	sort_b(a, b, 0);

	return (0);
}
*/
